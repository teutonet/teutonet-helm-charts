{{- if false }}
apiVersion: batch/v1beta1
{{- else }}
apiVersion: {{ include "common.capabilities.cronjob.apiVersion" . }}
{{- end }}
kind: CronJob
metadata:
  name: secret-sync
  namespace: {{ $.Release.Namespace }}
  labels: {{- include "common.labels.standard" $ | nindent 4 }}
spec:
  concurrencyPolicy: Forbid
  startingDeadlineSeconds: 50
  schedule: "* * * * *" # Every minute
  jobTemplate:
    spec:
      template:
        spec:
          volumes:
            - name: tmp
              emptyDir:
                medium: Memory
          securityContext:
            runAsGroup: 1000
            runAsUser: 1000
            runAsNonRoot: true
            fsGroup: 1000
          automountServiceAccountToken: true
          serviceAccountName: secret-sync
          restartPolicy: OnFailure
          containers:
            - name: secret-sync
              image: {{ template "base-cluster.kubectl.image" . }}
              {{- if .Values.global.kubectl.image.repository | contains "@" }}
              imagePullPolicy: IfNotPresent
              {{- else }}
              imagePullPolicy: Always
              {{- end }}
              securityContext:
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                    - ALL
                privileged: false
                readOnlyRootFilesystem: true
              volumeMounts:
                - mountPath: /tmp
                  name: tmp
              command:
                - bash
              args:
                - -ex
                - -c
                - |
                  {{- $certs := list -}}
                  {{- range $cert := .Values.global.certificates | keys -}}
                    {{- $certs = append $certs (printf "%s-certificate" $cert) -}}
                  {{- end -}}
                  {{- $secrets := concat (.Values.global.imageCredentials | keys) $certs }}
                  cd /tmp

                  for secret in {{ $secrets | join " " }}; do
                    kubectl -n {{ .Release.Namespace }} get secret "$secret" -o json \
                      | jq '.metadata = {"name": .metadata.name, "labels": {"base-cluster/synced": "true"}}' > "$secret.json"
                  done

                  rm -rf namespaces
                  mkdir namespaces
                  for namespace in $(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}' --field-selector=metadata.name!={{- .Release.Namespace -}}); do
                    mkdir namespaces/"$namespace"
                  done

                  {{- $targetsAllNamespaces := list -}}
                  {{- $targetsSpecificNamespaces := dict -}}
                  {{- $certMap := dict -}}
                  {{- range $name, $cert := .Values.global.certificates -}}
                  {{- $certMap := set $certMap (printf "%s-certificate" $name) $cert -}}
                  {{- end -}}
                  {{- $dicts := list $certMap .Values.global.imageCredentials -}}
                  {{- range $dict := $dicts -}}
                    {{- range $name, $cert := $dict -}}
                      {{- if typeIs "string" ($cert.targetNamespaces | default "ALL") -}}
                        {{- $targetsAllNamespaces = append $targetsAllNamespaces $name -}}
                      {{- else -}}
                        {{- $targetsSpecificNamespaces := set $targetsSpecificNamespaces $name $cert.targetNamespaces -}}
                      {{- end -}}
                    {{- end }}
                  {{- end }}

                  function addSecretToNamespace() {
                    local secret="$1"
                    local namespace="$2"
                    cat "$secret.json" | jq ".metadata.namespace=\"$namespace\"" > "namespaces/$namespace/$secret.json"
                  }

                  for namespace in namespaces/*; do
                    for secret in {{ $targetsAllNamespaces | join " " }}; do
                      addSecretToNamespace "$secret" "$(basename "$namespace")"
                    done
                  done
                  {{ range $secret, $namespaces := $targetsSpecificNamespaces }}
                  for namespace in {{ $namespaces | join " " }}; do
                    if [[ ! -d "namespaces/$namespace" ]]; then
                      echo "Specified namespace doesn't exist: '$namespace'" > /dev/stderr
                      exit 1
                    fi
                    addSecretToNamespace {{ $secret | quote }} "$namespace"
                  done
                  {{- end }}

                  kubectl apply -R -f namespaces/ --prune -l base-cluster/synced=true