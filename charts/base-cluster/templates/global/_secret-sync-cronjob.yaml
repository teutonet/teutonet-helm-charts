{{- define "base-cluster.secret-sync.cronjob" -}}
  {{- $secrets := .secrets }}
  {{- $targetsAllNamespaces := .targetsAllNamespaces -}}
  {{- $targetsSpecificNamespaces := .targetsSpecificNamespaces -}}

  {{- if not (empty $secrets) -}}
    {{- if false }}
apiVersion: batch/v1beta1
    {{- else }}
apiVersion: {{ include "common.capabilities.cronjob.apiVersion" .context }}
    {{- end }}
kind: CronJob
metadata:
  name: secret-sync
  namespace: {{ .context.Release.Namespace }}
  labels: {{- include "common.labels.standard" .context | nindent 4 }}
spec:
  concurrencyPolicy: Forbid
  startingDeadlineSeconds: 50
  schedule: "* * * * *" # Every minute
  jobTemplate:
    spec:
      template:
        spec:
          volumes:
            - name: tmp
              emptyDir:
                medium: Memory
          securityContext:
            runAsGroup: 1000
            runAsUser: 1000
            runAsNonRoot: true
            fsGroup: 1000
          automountServiceAccountToken: true
          serviceAccountName: secret-sync
          restartPolicy: OnFailure
          containers:
            - name: secret-sync
              image: {{ template "base-cluster.kubectl.image" .context }}
              {{- if .context.Values.global.kubectl.image.repository | contains "@" }}
              imagePullPolicy: IfNotPresent
              {{- else }}
              imagePullPolicy: Always
              {{- end }}
              securityContext:
                allowPrivilegeEscalation: false
                capabilities:
                  drop:
                    - ALL
                privileged: false
                readOnlyRootFilesystem: true
              volumeMounts:
                - mountPath: /tmp
                  name: tmp
              command:
                - bash
              args:
                - -ex
                - -c
                - |
                  cd /tmp

                  for secret in {{ $secrets | join " " }}; do
                    kubectl -n {{ .context.Release.Namespace }} get secret "$secret" -o json \
                      | jq '.metadata = { "name": .metadata.name, "labels": { "base-cluster/synced": "true" } }' > "$secret.json"
                  done

                  rm -rf namespaces
                  mkdir namespaces
                  for namespace in $(kubectl get namespaces -o jsonpath='{ .items[*].metadata.name }' --field-selector=metadata.name!={{- .context.Release.Namespace -}}); do
                    mkdir namespaces/"$namespace"
                  done

                  function addSecretToNamespace() {
                    local secret="$1"
                    local namespace="$2"
                    if [[ ! -d "namespaces/$namespace" ]]; then
                      echo "Specified namespace for secret '$secret' doesn't exist: '$namespace'" > /dev/stderr
                      exit 1
                    fi
                    cat "$secret.json" | jq ".metadata.namespace=\"$namespace\"" > "namespaces/$namespace/$secret.json"
                  }

                  {{ if not (empty $targetsAllNamespaces) -}}
                  for namespace in namespaces/*; do
                    for secret in {{ $targetsAllNamespaces | join " " }}; do
                      addSecretToNamespace "$secret" "$(basename "$namespace")"
                    done
                  done

                  {{ end -}}

                  {{ range $secret, $namespaces := $targetsSpecificNamespaces -}}
                  for namespace in {{ $namespaces | join " " }}; do
                    addSecretToNamespace {{ $secret | quote }} "$namespace"
                  done

                  {{ end -}}

                  kubectl apply -R -f namespaces/ --prune -l base-cluster/synced=true --prune-whitelist=core/v1/Secret
  {{- end -}}
{{- end -}}